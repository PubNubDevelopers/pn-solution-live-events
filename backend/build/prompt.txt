Live Events Demo - Backend Definition
4 Primary purposes of the backend:
Send data to the frontend via PubNub that is in sync with the video playing in the client browser
All viewers will be watching a synchronized video, so they are all seeing the same thing
Synchronizing the data with the video will make the experience more realistic, e.g. chat messages discuss what is happening in the game and "cheer" at the correct times.
Logic should allow the video to loop, and allow new joiners after the video has started 
(the self-led scenario will run in a continual loop all the time)
Respond to requests initiated by the "Data Controls" panel (which is used exclusively by a sales person as part of a guided demo)
Two types of action based on these controls:
1: Skip to a specific position in the live stream (e.g. start it, skip 5 minutes to the end).  
2: Cause additional data messages to be sent (e.g. "Fan excitement" will generate 20 "cheer" emoji; "Fan frustration" will generate 25 "anger" emoji).

How it works:
Send data to the frontend via PubNub that is in sync with the video playing in the browser:
There will exist a JSON array to map video timecodes to actions, e.g. 
[
  {
    timeSinceVideoStartedInMs: 5,
    //  (whether or not to persist the sent message, defaults to false if unspecified)
    persistInHistory: bool,
    action: {
      //  Message to be sent on this channel
      channel: <string> ,
      //  This JSON object is the body of the "message" object
      data: <params, as defined in table below>
    }
  },
  //  more time codes mapped to actions
]
Possible actions with params (using the Core SDK, unless otherwise specified):
Note: Each row represents a different PubNub channel.
Action (Message)
Params
Send Chat Message
Channel: game.chat
Definition in Array is as follows:
{user: "bot-01", text: "message text"}
Which will result in a Chat SDK call for the instance associated with the specified user as follows:
channel?.sendText(“message text”)
Alternatively:
{user: "bot-01", specialTaggedMessage: true}
Which is only used for the Data Controls "Tag user in message" request.  This results in the Chat SDK sending a message from the specified user (bot-01 in the example) as follows “Hello @currentUser” where currentUser is the actual name of the logged in user.  There will need to be a way of sending the chat.currentUser.id along with the "tag user in message" request.  Should use the Chat SDK as detailed in the docs.
Live Commentary
Channel: game.commentary
Commentary containing text and the time at which that commentary happened on the game clock
{text: “Commentary text”,
timeCode: “MM:ss”}
Reactions shown over video overlay
Channel: game.stream-reactions
Emoji to show.  This message will trigger 1 emoji of the specified type
{text: "🎉", type: "reaction"}
Poll: New Poll
Channel: game.new-poll
ID, title, options [id, optionText], points for correct answer (optional), type (i.e. below the live stream, or in the dedicated poll widget)
{id: number, title: “Poll Title”, victoryPoints: number, pollType: “side”, alertText: “New Poll”, options [{id: 1, “text”: “YES”},{id: 2, “text”: “NO”}]}
Above example is for a poll with two choices, "yes" and "no". pollType refers to where the UX should position the poll and can be either "side" (on the RHS, within the dedicated poll widget) or "match" (directly below the live stream)
Note: Only the live stream poll will be persisted in PubNub history
Poll: Vote (front end graph of answers will update in real-time as others vote on the poll - they do not have to wait for the poll results)
Channel: game.poll-votes
{pollId: number,
questionId: "1",
choiceId: number,
pollType: “side”}
PollId refers to the ID given to the poll when it was first created.  choiceId refers to a previously declared "options" id when the poll was declared
Poll: Results
Channel: game.poll-results
Same as "new poll", but omitting "alertText and including the "correct answer" (optional) and the results for each option - the front end is not expected to tally each poll vote, since they might join late
{id: number, title: “Poll Title”, victoryPoints: number, pollType: “side”, correctOption: 2, options [{id: 1, “text”: “YES”, score: 33},{id: 2, “text”: “NO”, score: 47}]}
Note: It would be great if the poll results were the ACTUAL count of the votes that were passed.  I.e. the total of the scripted votes AND any votes made by users interacting with the app, so they affect the outcome. - This means the poll results (options scores) would NOT be scripted, but generated by the backend.
Match Stats
Channel: game.match-stats
JSON object containing the current match stats (or more likely a subset thereof).  So, when somebody scores a goal, or gets a yellow card, the stat associated with that will update.
This is highly configurable in the app, but one example might be:
statBox1: {
         info: [
           {
             stat: “30%”
           },
           {
             stat: 70%"
           }
         ]
       },
       statBox2: {
         info: [
           {
             stat: 5
           }
         ]
       },
There are 6 stat boxes, which can be each of 3 different "box types"
Send Push notification
Channel: game-push-sales (For sales-led demo)
Channel: game-push-self (For self-led demo)
Push message Title + body text .  Test either in app (simulated notification on web) or in emulator (Under "push notifications" → "open emulator")
pn_fcm: {
Text: "",          
data: { title: “Notification title”, body: “notification Body” }
        }
Note that there are separate channels for the sales-led demo and self-led demo because they use different keysets but I didn"t want to create two Firebase projects and two different service account keys… so to keep the messages separated, I just used two different PN channels.
Keysets to exchange messages over are as follows:
Keyset Purpose
Pub/Sub Keys
Hosted App
Sales-Led
pub-c-61f29af2-2b8d-43a0-9209-75ad2bfb85d6
sub-c-fa08eb13-6d22-48f9-91a4-1d6eae913127
Link
Self-Led
pub-c-e97a3395-cdc4-4eed-b06f-58faa059bc1b
sub-c-11080239-8b55-4fa1-81ec-5af6c716e59a
Link
Testing
pub-c-787fb20a-4d32-42f5-aa55-f990979f5a0a
sub-c-f19c6fb1-c3a7-4a3b-bfaa-d424634e59e7

A process will exist for the duration of video playback to periodically (say every 500ms):
Check which actions should have been executed since the last time the function ran, and send all the appropriate messages over PubNub.
I think this will be sufficient to avoid drift between what video the client is viewing, and what data they are receiving from the backend.
Send a control message containing the current video playback time (allowing new joiners to sync their front end video stream with the data being sent)
Remember the video will also loop, so this control message should also allow the frontend to handle that 
Video Status (Message)
Params
Video status
{
type: "STATUS"
params: 
  {
    playbackTime: number // in ms,
    videoStarted: boolean //  only for first message of video loop
    videoEnded: boolean //  only for last message of video loop
  }
}
Playback time is the current video seek position
videoStarted and videoEnded are used by the client for additional stream control
2. Respond to requests initiated by the "Data Controls" panel (which is used exclusively by a sales person as part of a guided demo)
If skipping to a new location in the steam, send a "seek" message to this effect and skip to the appropriate location in the video timecode array previously described.
Front end clients will receive the "seek" message, and adjust their playback location
Dedicated message for start stream ("kickoff") and stop stream ("end match").  
Action (Message)
Params
Start stream
{
type: "START_STREAM"
params: {}
}
Video seek
Time to seek to in ms
{
type: SEEK
params: 
  {
    playbackTime: number //  in ms
  }
}
End stream
{
type: END_STREAM
params: {}
}
Any messages sent in response to the "Data Controls" panel are in addition to the periodic messages described previously. 
Assume that for each message in the "data controls" panel there will be an individual JSON array, processed when the message from "data controls" is received, and run in parallel to the JSON array described in section 1:  
Data Controls request
Info
Kick Off
Results in a "start stream" message
Goal
Results in a "video seek" message.  The "Goal request will need to contain the time to seek to
Fan Excitement
Results in a custom action array being run (example is given below)
Fan frustration
Results in a custom action array being run
Five minutes remaining
Results in a "video seek" message.  The request will need to contain the time to seek to 
End Match
Results in an "End stream" message
Tag User in Message
Results in a custom action array being run.  This uses special logic for tagging a user using the Chat SDK, see definition of "Send Chat Message" under the actions array above
E.g. for "Fan Excitement"
[
{
channel: "game.streamreactions",
data: {text: "🎉", type: "reaction"}
},
{
channel: "game.streamreactions",
data: {text: "🎉", type: "reaction"}
},
{
channel: "game.streamreactions",
data: {text: "🎉", type: "reaction"}
},
{
channel: "game.streamreactions",
data: {text: "🎉", type: "reaction"}
},
{
channel: "game.streamreactions",
data: {text: "🎉", type: "reaction"}
},
… About 15 more times, plus also with the 🙌 emoji
]


Have you ever watched one of those really polished live events online and thought, how do they make all that interactive stuff happen so smoothly? Yeah, it really is like magic sometime. Well, today we're going backstage at a live events demo, kind of like getting a peek behind the curtain. We've got these internal documents that lay out how the tech set up. We're going to break down the key insights. Cool. Think of it like getting the cheat sheet for understanding the magic happening behind your screen. I like that analogy. So these documents, they're pretty fascinating. Yeah, they give us a glimpse under the hood, you know, they show how different parts of the system, well they communicate with each other to create this synchronized, engaging experience that you see as a viewer. It's kind of like figuring out how all the instruments in an orchestra work together to play a single piece of music, if you will. That's a really good way to put it. So our objective today is pretty simple. We want to understand what the core functions of this backend system are. And most importantly, how it makes sure that anyone watching this demo has a seamless and dynamic experience. Right. So let's dive in. Let's do it. Our sources tell us that the backend has four main things it needs to do. First up, it's all about keeping everything in sync. Exactly. The first core job is to send data, things like chat messages and emoji reactions to what you see on your screen. Right. That's called the front end. Okay. And it needs to do this using a technology called PubNub. PubNub. PubNub. Yeah. Okay. In a way that's perfectly timed with the video you're watching. So everything's happening when it should. So like everyone watching is at the exact same point in the video. Yes. No matter when they joined. Right. And like when someone sends a chat message reacting to a funny moment or there's like a sudden burst of cheers after a great play, it all has to happen at the right time, the precise instant. Yeah. So it feels real. To feel real, to feel live. The documents actually mentioned this goal of creating a realistic experience. And that's exactly what it's all about. It's this meticulous timing of the data with the video that creates that immersive and believable live feeling. If a chat message refers to something you haven't seen yet, or if the reactions are out of sync, the whole illusion breaks down. The magic's gone. Poof. Right. And what's also really interesting is how they handle the video looping. Oh yeah. Especially in those self-guided demos, you know, and how new viewers can just jump in at any point. Right. The backend needs to make sure that they get synced up instantly. Which brings us to our second core purpose. Yeah. Responding to something called the data controls panel. Yes. Now this is something that you and I wouldn't see as regular viewers. No, this is behind the scenes. Right. This is more for the salesperson who's leading a guided demo. Okay. So this panel gives them a set of tools to kind of steer the demo in real time. The documents highlight two main types of actions they can trigger. The first is pretty simple. They can skip to different parts of the video. Okay. Start it over, jump to a key moment, you know, things like that. Right. To keep the demo flowing. But the second type of action, this sounds really cool. Triggering extra data messages. What does that mean? So this is where things get interesting. The salesperson can actually hit buttons on their control panel that instantly send out pre-programmed actions. So for example, there's a fan excitement button. And if they hit that it might automatically flood the chat with like 20 cheer emojis. Oh wow. Or if they want to show a different vibe, there's a fan frustration button that could generate 25 anger emojis. Oh, that's kind of cool. It's like they have a remote control for audience reactions. You know, so they can really control the feel of the demo. Exactly. They can dynamically inject engagement without having to manually type out dozens of emojis. And this actually reveals a key strategy. They're using these automated reactions to subtly highlight the power and responsiveness of their Illuminate platform without being too intrusive. Right. It's about showing, not telling. It's like a quick way to highlight key moments and to demonstrate audience sentiment. Yes, exactly. But documents also mentioned something called an Illuminate decision related to these emoji reactions. Yes. What is the connection there? So what's really fascinating here is how they're using this to showcase what their Illuminate platform can do. By having these automated bursts of reactions, the salesperson can subtly demonstrate how Illuminate could respond to certain levels of engagement. I see. Say if a certain number of cheers happen, Illuminate could automatically trigger another event all without the salesperson having to manually orchestrate everything. Right. But it's important to remember that you as a regular user can still send those same reactions yourself if you want to. It's just about showing the possibilities, the platform's capabilities. Gotcha. That's a really clever way to kind of sneak in their product features within the demo itself. Yeah, it's very subtle. Yeah. Now the third core purpose involves the backend responding to requests directly from Illuminate to start polls on demand. Yes. How does that work? This points to a level of smart automation that's happening behind the scenes. Okay. It's driven by what's actually happening in the live event. So imagine the system is constantly monitoring the chat, you know, or the flow of emoji reactions. Okay. And if it sees a certain pattern, say, for example, the documents mentioned more than 20 cheer emojis popping up within a minute. Wow. Illuminate can automatically tell the backend to launch a poll related to that exciting moment in the demo. Gotcha. So it adds this whole other layer of interactivity that's driven by the audience's engagement itself. That's really cool. It is. And you see how all these different data streams through PubNub are essential for fulfilling this third core purpose, enabling these interactive polls that react in real time. So it's not just the person running the demo who can trigger things. The system itself can react to how the audience is interacting. Exactly. That is pretty dynamic. Yeah. And the fourth and final core purpose, it's all about resetting all the Illuminate objects in the sales demo account. Why is this so important? Well, think about it. If multiple salespeople are using the same demo account to show off their product, they might make changes, right? Like creating new polls, tweaking settings, things like that. Right. So to make sure that the next person using the demo has a clean slate and everything works as expected, they need to reset everything to its original state. So that reset demo button essentially wipes everything clean. And the documents specifically point out that this reset logic has to live on the backend. Yeah. Because the Illuminate API, the way that different software systems talk to each other securely requires a password. Right. And that makes sense. It's about security. You wouldn't want those credentials exposed on the front end for everyone to see. Exactly. It's all about keeping sensitive information safe and sound. Absolutely. And ensuring the demo environment is always in a ready to go state. Okay. So we've covered the four main things the backend needs to do. Right. Now let's dig into how all of this data actually gets sent and synchronized with the video you're watching. Okay. And the key technology here seems to be PubNub. PubNub, it's the heart of it all. So these four core purposes, that gives us a good understanding of what the backend needs to do. Yeah. Now let's go back the curtain further and see how it actually achieves this. And we'll start with a technology that powers the real-time communication, which is PubNub. PubNub, our trusty messenger. Right. PubNub is described as the technology that ferries real-time data to the front end, which is what you see. Exactly. Our documents mentioned something called a JSON array that maps video time codes to specific actions. Think of it as a super detailed script that tells the system what to do and when down to the millisecond in the video. Can you break down what that looks like? Okay. So imagine a timeline of the video marked down to the millisecond. Okay. This JSON array is like a script that runs in the background. Right. At very precise moments in the video, it tells the backend to perform specific actions. Okay. So each entry in the script has a time since video started in ems, which is basically just how many milliseconds have passed in the video and then an action object. Okay. This action object specifies the channel. Think of it like a specific radio frequency for different types of messages. And then the actual data, which is the content of the message itself. So it's like a super precise instruction list that's locked to the video's progress. Right. And these instructions get sent out on different PubNub channels. Like different pathways for the data. Let's look at some examples. The first one is game.chat. Okay. Clearly this is for sending chat messages. Correct. And the format for sending a chat message is pretty straightforward. It includes who sent the message. So the user and what they said, the text. Gotcha. So for example, you might see something like user, bot01 text, message, text. The backend then takes this information and uses their chat SDK, a set of tools for building chat features to display that message in the chat window you see. But what's interesting is how they handle the special feature of tagging the current user. Yes. The at current user mentioned. Yes. How does that work behind the scenes to personalize it for each viewer? So for that, they use a slightly different format. User, bot01, special tag message. Okay. When the backend sees this, it knows it needs to send a message that will appear as something like, hello at your user, but it dynamically inserts the actual username of whoever's logged in. Right. To do this, the backend needs to know the chat.currentuser.ad. Makes sense to make the experience more personal. Yeah. What about the game.commentary channel? That sounds like it's for those preplanned spoken bits during the demo. Exactly. That's for prerecorded commentary. That's time to play at specific points in the video. The format is pretty simple. Text, commentary, text, timecode, MS, Jando. It just ensures that the right voiceover plays at the exact right moment in the video for everyone. Cool. And then we have game.stream reactions for those fun emojis that pop up over the video. How do they work? So to trigger a single emoji appearing on screen, the backend sends a message like text S type reaction, and the front end then knows to display that specific emoji. In this case, it would be the confetti emoji. Fun. Now let's get into the polls. There are quite a few channels related to that. First, game.new-poll for when a new poll pops up. What are the key pieces of information it sends? So this channel defines all the important details about the poll. A unique id, so the system knows which poll it is. Okay. The title, which is the question being asked, and then the options, which is a list of possible answers. Each with its own id and the option text. Makes sense. It also includes points for correct if it's a quiz style poll and the poll type, which tells the front end how to display the poll either side, meaning in a separate panel or match, meaning it appears below the live stream. And then there's an optional alert text, which is used to customize the notification you see when a new poll becomes available. Like that you unlocked a poll example when it's triggered by Illuminate. And it's worth noting that only the polls shown during the live stream are saved in PubNub's history. Okay. So that sets up the poll itself. Then we have game.pollvotes. How are everyone's votes tracked as they come in? So when you cast your vote, the front end sends a message to this game.pollvotes channel. This message includes the pollid to identify which poll you're voting on. The questionid, which seems to be consistently one in these examples, the choiceid that corresponds to the option you selected, and then the poll type again. This allows the back end to keep a real time tally of all the votes and update the results you see on your screen. And that leads us to game.pollresults. This is where the outcome of the poll is presented. Correct. The game.pollresults message includes the same basic poll information as when the poll was created, but it leaves out that initial alert text. Instead it includes the correct option if there was a right answer and crucially the real time score for each option. Now the document specifically says that these scores aren't just pre-programmed. They're actually calculated on the back end, taking into account both any prescripted actions they might've included and all the actual votes cast by you and the other viewers. Wow. So the poll results are a live reflection of everyone's input. Exactly. It's truly interactive. That's really neat. What about game.matchstats? How are those real time updates handled? The game.matchstats channel sends out a package of information in a format called JSON that contains the current stats of whatever event is being shown. The structure is quite flexible using things called stat box objects that contain lists of info. For example, you might see something like stat box one info stat 30%, 70%. The documents mentioned, there are six of these stat boxes in total and they can be displayed in three different ways, which suggests they have a lot of flexibility in showing various kinds of real time data. That makes sense. Okay. So we're getting a good sense of all the different streams of data flowing through PubNub. It's a lot to keep track of. It really is. Now there are also channels for push notifications, game push sales and game push self. Why have two separate channels for those? Well, as the documents explain, these are for sending those little pop-up notifications to your device. And each notification has a title and a body. Makes sense. The reason they have separate channels, one for demos led by a salesperson and one for self-guided demos is because they actually use different PubNub key sets. Key sets. Key sets. Yeah. Okay. Think of those as different secure communication lines. Instead of having two completely separate projects, they've opted for these distinct channels to keep the messages separate and secure. Essentially, these keys are like different access codes that allow different parts of the system, like the sales demo versus the self-guided demo to communicate securely and separately. Ah, that's a practical way to manage different types of demos. It is. Speaking of these key sets, the document lists three. Sales led, self-led and testing. Okay. And each has its own set of these publish and subscribe keys, as well as a link to a hosted app. Right. This gives us a glimpse into the infrastructure behind the scenes. Doesn't it? Absolutely. It shows the different environments they set up for development testing and the two main types of demos they offer. Now alongside all of these specific actions that happen based on the video's timeline, there's also this continuous process running in the background every 500 milliseconds. Okay. That's twice every second. What does this constant background activity do? It sounds like it's crucial for keeping everything in sync. It is. This process has two main jobs. First, it checks that script we talked about earlier, that JSON array. Right. And it sees which actions should have happened since the last time it checked. Then it sends out all those relevant messages over PubNub. The goal here is to prevent any lag between what's happening in the video and the data you're seeing. It's like a conductor keeping the orchestra in time. Exactly. And the second job of this periodic process is to send out a video status message. Okay. This message includes the current playback time in milliseconds. Gotcha. So everyone knows exactly where the video is. Right. And it also has little flags that indicate if the video has just started playing or if it has just ended a loop. This is super important for anyone who joins the demo late so their video can instantly jump to the right spot and they can get in sync with all the ongoing data. Makes sense. It also handles the looping of the video in those self-guided demos. So it's like a constant heartbeat of synchronization making sure everyone's on the same page. Yeah. Or rather the same millisecond. Right. Now let's circle back to those data controls that the salesperson uses. Yeah. We talked about them triggering extra data messages. Yeah. But how do they fit into this whole system of timed events and background processes? So when a salesperson clicks a button on the data controls panel, these requests trigger actions immediately. In addition to that regular background process we just discussed, for example, hitting the kickoff button simply sends a start stream message. Okay. Similarly, clicking end match sends an end stream message. Okay. It's very straightforward. And what about those options to jump to specific points in the video, like clicking goal or five minutes remaining? Those actions trigger a seek message. And this message includes the playback time in milliseconds that the video should jump to. So when the front end receives this, your video player will just jump to that specific time. And importantly, the backend also updates its place in that video timecode script of actions to make sure everything stays synchronized. Makes sense for quickly navigating through key moments in the video, but the fan excitement, fan frustration and tag user and message options are described as triggering custom action arrays running in parallel. What does that mean exactly? So instead of just sending a single message, these controls actually initiate a predefined sequence of actions. Think of it like a mini program that runs when the salesperson clicks the button. The fan excitement example in the document is a great illustration. It triggers a whole series of those game doc stream reactions messages, sending out multiple cheer and applause emojis in quick succession. The tag user and message also triggers a set of actions, but this one uses that special chat SDK logic we talked about earlier to make sure the currently logged in user gets tagged in the chat. So it's like these buttons unleash a flurry of preset actions allowing for more complex and immediate responses than just a single event. Right. Now let's move on to how the backend responds to those initiate polls requests from Illuminate. Okay. We know these polls can be triggered automatically based on certain conditions. Right. So beyond the salesperson's direct control, the system itself can also initiate actions based on audience engagement. Yes. Let's explore how that works. So Illuminate can be set up to send a request to the backend, to launch a specific poll when certain things happen. Okay. Like say reaching that threshold of more than 20 cheer emojis we mentioned. Right. The documents also mentioned the need for a cool down period to make sure the same poll doesn't get launched over and over again if the triggering condition keeps happening. Yeah. That makes sense. You don't want to bombard people with the same poll over and over again. No, you don't want to overdo it. And the backend has this system of action arrays that are linked to specific IDs. Yeah. And these get triggered by the requests from Illuminate. Tell us more about how that works. So just like with those data controls, the salesperson uses, the backend has a collection of pre-programmed sets of actions. Okay. And each set has its own unique ID. Gotcha. When Illuminate sends a request with a particular ID, the backend knows exactly which set of actions to execute. In the case of launching a poll, this set of actions would include sending out that game.new-poll message with all the details of the poll that we discussed earlier. And the documents give us a couple of specific examples of these poll IDs. 001 is for the poll asking which team's fans are celebrating the hardest. And 002 is for which team is playing the dirtiest. It's interesting to note that even though these polls are triggered automatically, the results should still reflect the actual votes cast by the audience. That's a really important point. Whether a poll is started by the salesperson clicking a button or automatically by Illuminate based on audience engagement, the backend is always responsible for collecting and tallying up all the votes, both any pre-scripted votes they might've included and all the real-time votes coming in from you and the other viewers to generate the final poll results you see. So we've covered how data is sent and synchronized, how the data controls work and how Illuminate can automatically trigger polls. Finally, let's revisit that fourth core purpose, resetting those Illuminate objects. Okay. We know it's essential for ensuring a consistent demo for everyone. Right. So when a salesperson logs in and clicks that reset demo button, it sends a signal to the backend. Yes. The backend then uses the Illuminate API, that secure way for systems to talk to each other without exposing the password on the front end to reset all the relevant elements within the sales demo account back to their original default settings. Right. It's like hitting the reset button on the whole system. So the backend is acting as a secure middleman, managing the state of that Illuminate demo environment behind the scenes. It's really fascinating to see how all these different pieces work together to create a seamless experience for you. Absolutely. You have the constant flow of real-time data synchronized with the video, the on-demand controls for the salesperson to guide the story, the automated interactivity driven by Illuminate reacting to the audience and that crucial function of resetting everything to ensure a consistent starting point. It's a complex, but incredibly well-orchestrated system. So to bring our deep dive to a close, we've seen how this backend plays a vital role in making sure the live event demo is both synchronized and interactive. Yeah. It's so much more than just streaming video. It really is. It's this intricate dance of data, responding to commands and even reacting automatically to how you and other viewers are engaging with the content. It's like a living breathing system. And all of this comes together to create that smooth and engaging experience you see on your screen. Right. The magic behind the curtain. And, you know, the next time you're watching a really slick live online event and everything just feels perfectly in sync and interactive, remember there's this whole hidden world of technology working tirelessly behind the scenes to make it all happen. It really is incredible when you think about it. Yeah. Considering the complexity we've uncovered in just this one demo backend, what other unseen systems do you think are at play in all the digital experiences you encounter every day? It's mind boggling. And how might having a better understanding of these hidden workings empower you to engage with technology in a more informed and effective way? That's a good question. It's definitely something to ponder. Thanks for joining us on this deep dive. It was my pleasure. Yeah, mine too. Always fun to peek behind the curtain. Absolutely. See how the magic works.
